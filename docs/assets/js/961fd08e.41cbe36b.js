"use strict";(self.webpackChunkmedia_processor_docs=self.webpackChunkmedia_processor_docs||[]).push([[123],{3905:(e,r,t)=>{t.d(r,{Zo:()=>p,kt:()=>m});var n=t(7294);function a(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function i(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function o(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?i(Object(t),!0).forEach((function(r){a(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function s(e,r){if(null==e)return{};var t,n,a=function(e,r){if(null==e)return{};var t,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],r.indexOf(t)>=0||(a[t]=e[t]);return a}(e,r);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=n.createContext({}),c=function(e){var r=n.useContext(l),t=r;return e&&(t="function"==typeof e?e(r):o(o({},r),e)),t},p=function(e){var r=c(e.components);return n.createElement(l.Provider,{value:r},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},g=n.forwardRef((function(e,r){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(t),g=a,m=d["".concat(l,".").concat(g)]||d[g]||u[g]||i;return t?n.createElement(m,o(o({ref:r},p),{},{components:t})):n.createElement(m,o({ref:r},p))}));function m(e,r){var t=arguments,a=r&&r.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=g;var s={};for(var l in r)hasOwnProperty.call(r,l)&&(s[l]=r[l]);s.originalType=e,s[d]="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=t[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,t)}g.displayName="MDXCreateElement"},7406:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=t(7462),a=(t(7294),t(3905));const i={sidebar_position:2},o="Renderers",s={unversionedId:"renderers",id:"renderers",title:"Renderers",description:"When building a graphics rendering library, it's important to ensure that it can work on a wide variety of devices, including those with limited graphics capabilities. The two available types of renderers  are Canvas 2D and WebGL.",source:"@site/docs/renderers.md",sourceDirName:".",slug:"/renderers",permalink:"/ml-transformers-docs/docs/renderers",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Vonage ML Transformers",permalink:"/ml-transformers-docs/docs/intro"},next:{title:"Postprocessing",permalink:"/ml-transformers-docs/docs/post-processing"}},l={},c=[{value:"Canvas 2D",id:"canvas-2d",level:2},{value:"WebGL",id:"webgl",level:2},{value:"Postprocessing",id:"postprocessing",level:2},{value:"Hardware impact",id:"hardware-impact",level:2},{value:"Default renderer",id:"default-renderer",level:2},{value:"Selecting renderer",id:"selecting-renderer",level:2}],p={toc:c},d="wrapper";function u(e){let{components:r,...t}=e;return(0,a.kt)(d,(0,n.Z)({},p,t,{components:r,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"renderers"},"Renderers"),(0,a.kt)("p",null,"When building a graphics rendering library, it's important to ensure that it can work on a wide variety of devices, including those with limited graphics capabilities. The two available types of renderers  are Canvas 2D and WebGL."),(0,a.kt)("h2",{id:"canvas-2d"},"Canvas 2D"),(0,a.kt)("p",null,"Canvas 2D is an API that offers a 2D drawing context for the HTML canvas element. It's simple to use and allows you to draw shapes, text, images, and other graphics directly onto a canvas. It has good performance for simple graphics operations."),(0,a.kt)("h2",{id:"webgl"},"WebGL"),(0,a.kt)("p",null,"WebGL, is a graphics API that grants access to the user's computer's graphics hardware, making it possible for developers to produce advanced 3D graphics and animations straight in the web browser. WebGL is built on top of OpenGL, a widely used graphics API in game development and other graphics-heavy applications. It provides high-performance graphics rendering."),(0,a.kt)("h2",{id:"postprocessing"},"Postprocessing"),(0,a.kt)("p",null,"To reduce flickering in selfie segmentation, a post-processing operation can be applied using a temporal smoothing filter. However, this technique is only available with WebGL due to its access to previous frames rendered by the GPU. Ending in a difference between the Canvas2d and WebGL segmentation."),(0,a.kt)("h2",{id:"hardware-impact"},"Hardware impact"),(0,a.kt)("p",null,"If the user's computer lacks a GPU, both Canvas 2D and WebGL will still work, but the performance and rendering quality may differ. Canvas 2D graphics rendering is handled by the CPU, so performance is reliant on the complexity of the graphics being produced and the user's CPU. On the other hand, WebGL graphics rendering is designed to take advantage of GPU acceleration, so the absence of a GPU will result in a significant decrease in performance, particularly for complex graphics operations."),(0,a.kt)("h2",{id:"default-renderer"},"Default renderer"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext"},"failIfMajorPerformanceCaveat")," flag is an optional parameter that can be passed to the getContext() method when retrieving a canvas context. When set to true, the browser will fail to return a context that indicates limited or reduced capabilities. In this scenario, Canvas 2D is used by the library. Otherwise, good GPU performance can be expected, and WebGL will be chosen as the default renderer."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null}),(0,a.kt)("th",{parentName:"tr",align:null},"high perfomance GPU"),(0,a.kt)("th",{parentName:"tr",align:null},"low performance GPU"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Blur"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("a",{parentName:"td",href:"https://vonage.github.io/ml-transformers-docs/docs/api/enums/WebglSelfieSegmentationType#fast"},"webGL Fast")),(0,a.kt)("td",{parentName:"tr",align:null},"Canvas 2D")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Virtual Background"),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("a",{parentName:"td",href:"https://vonage.github.io/ml-transformers-docs/docs/api/enums/WebglSelfieSegmentationType#precise"},"webGL Precise")),(0,a.kt)("td",{parentName:"tr",align:null},"Canvas 2D")))),(0,a.kt)("h2",{id:"selecting-renderer"},"Selecting renderer"),(0,a.kt)("p",null,"If you want to select explicitly the renderer, you can use the renderingOptions field of the config."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-typescript"},"// \nconst canvas2dProcessor = await createVonageMediaProcessor({\n    transformerType: 'BackgroundBlur',\n    renderingOptions: { \n        type: RenderingType.CANVAS\n    }\n});\nconst webglProcessor = await createVonageMediaProcessor({\n    transformerType: 'BackgroundBlur',\n    renderingOptions: { \n        type: RenderingType.WEBGL\n    }\n});\n")))}u.isMDXComponent=!0}}]);